import { Question } from '@/types';

// Questões completas cobrindo 100% dos objetivos do exame
export const questionsComplete: Question[] = [
  // ============================================
  // DOMAIN 1: Snowflake SQL for Data Analysis
  // ============================================
  
  // Window Functions
  {
    id: 'qc-sql-1',
    topicId: 'topic-1-1',
    domainId: 'domain-1',
    question: 'Qual é o frame specification padrão quando ORDER BY está presente em uma window function?',
    options: [
      'ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING',
      'RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW',
      'ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING',
      'ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING',
    ],
    correctAnswer: 1,
    explanation: 'O frame padrão com ORDER BY é RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW. Isso afeta funções como LAST_VALUE() - por isso sempre especifique o frame explicitamente!',
    difficulty: 'hard',
    tags: ['window-functions', 'frame'],
  },
  {
    id: 'qc-sql-2',
    topicId: 'topic-1-1',
    domainId: 'domain-1',
    question: 'Você quer dividir seus clientes em 5 grupos de tamanho igual baseado em vendas. Qual função usar?',
    options: ['RANK()', 'PERCENT_RANK()', 'NTILE(5)', 'ROW_NUMBER()'],
    correctAnswer: 2,
    explanation: 'NTILE(n) divide as linhas em n grupos (buckets) de tamanho aproximadamente igual, perfeito para segmentação de clientes.',
    difficulty: 'easy',
    tags: ['window-functions', 'ntile'],
  },
  {
    id: 'qc-sql-3',
    topicId: 'topic-1-1',
    domainId: 'domain-1',
    question: 'Qual cláusula permite filtrar resultados de window functions diretamente sem subquery?',
    options: ['WHERE', 'HAVING', 'QUALIFY', 'FILTER'],
    correctAnswer: 2,
    explanation: 'QUALIFY é exclusivo do Snowflake e permite filtrar resultados de window functions após o cálculo, eliminando a necessidade de CTEs ou subqueries.',
    difficulty: 'easy',
    tags: ['qualify', 'snowflake-specific'],
  },
  {
    id: 'qc-sql-4',
    topicId: 'topic-1-1',
    domainId: 'domain-1',
    question: 'Para calcular a diferença entre o valor atual e o valor do dia anterior, qual função usar?',
    options: ['FIRST_VALUE()', 'LAST_VALUE()', 'LAG()', 'LEAD()'],
    correctAnswer: 2,
    explanation: 'LAG(col, offset) acessa o valor de n linhas ANTERIORES. Para diferença com dia anterior: valor - LAG(valor, 1) OVER (ORDER BY date)',
    difficulty: 'easy',
    tags: ['window-functions', 'lag'],
  },
  {
    id: 'qc-sql-5',
    topicId: 'topic-1-1',
    domainId: 'domain-1',
    question: 'Qual é a diferença entre ROWS e RANGE no frame specification?',
    options: [
      'ROWS é mais rápido que RANGE',
      'ROWS conta linhas físicas, RANGE usa valores lógicos',
      'RANGE não suporta UNBOUNDED',
      'Não há diferença, são sinônimos',
    ],
    correctAnswer: 1,
    explanation: 'ROWS conta linhas físicas independente dos valores. RANGE usa valores lógicos com base no ORDER BY, agrupando valores iguais.',
    difficulty: 'hard',
    tags: ['window-functions', 'frame'],
  },

  // String Functions
  {
    id: 'qc-sql-6',
    topicId: 'topic-1-1',
    domainId: 'domain-1',
    question: 'Qual função extrai parte de uma string usando expressão regular?',
    options: ['SUBSTRING()', 'SPLIT_PART()', 'REGEXP_SUBSTR()', 'SPLIT()'],
    correctAnswer: 2,
    explanation: 'REGEXP_SUBSTR() extrai substrings usando padrões de expressão regular, permitindo extrações complexas como domínios de email.',
    difficulty: 'medium',
    tags: ['string-functions', 'regex'],
  },
  {
    id: 'qc-sql-7',
    topicId: 'topic-1-1',
    domainId: 'domain-1',
    question: 'Qual função divide uma string em um ARRAY?',
    options: ['SPLIT()', 'SPLIT_PART()', 'STRTOK()', 'EXPLODE()'],
    correctAnswer: 0,
    explanation: 'SPLIT(string, delimiter) retorna um ARRAY. SPLIT_PART() retorna uma única parte específica como STRING.',
    difficulty: 'easy',
    tags: ['string-functions', 'array'],
  },

  // Date Functions
  {
    id: 'qc-sql-8',
    topicId: 'topic-1-1',
    domainId: 'domain-1',
    question: 'Qual função trunca uma data para o início do mês?',
    options: ['DATE_TRUNC(\'month\', date)', 'TRUNC(date, \'MM\')', 'EXTRACT(month FROM date)', 'LAST_DAY(date)'],
    correctAnswer: 0,
    explanation: 'DATE_TRUNC(\'month\', date) trunca a data para o primeiro dia do mês. É muito usado para agregações mensais.',
    difficulty: 'easy',
    tags: ['date-functions'],
  },
  {
    id: 'qc-sql-9',
    topicId: 'topic-1-1',
    domainId: 'domain-1',
    question: 'Qual função você usaria para agrupar dados em intervalos de 15 minutos?',
    options: ['DATE_TRUNC()', 'TIME_SLICE()', 'DATEADD()', 'EXTRACT()'],
    correctAnswer: 1,
    explanation: 'TIME_SLICE(time, 15, \'MINUTE\') alinha timestamps para intervalos regulares de 15 minutos, perfeito para agregação de séries temporais.',
    difficulty: 'medium',
    tags: ['date-functions', 'time-series'],
  },

  // Conditional Functions
  {
    id: 'qc-sql-10',
    topicId: 'topic-1-1',
    domainId: 'domain-1',
    question: 'Qual função retorna o primeiro valor não-NULL de uma lista?',
    options: ['NVL()', 'IFNULL()', 'COALESCE()', 'NVL2()'],
    correctAnswer: 2,
    explanation: 'COALESCE(a, b, c, ...) aceita múltiplos argumentos e retorna o primeiro não-NULL. NVL e IFNULL aceitam apenas 2 argumentos.',
    difficulty: 'easy',
    tags: ['conditional-functions', 'null-handling'],
  },
  {
    id: 'qc-sql-11',
    topicId: 'topic-1-1',
    domainId: 'domain-1',
    question: 'Qual a diferença entre NVL2(a, b, c) e NVL(a, b)?',
    options: [
      'NVL2 aceita mais tipos de dados',
      'NVL2 retorna b se a não é NULL, c se é NULL. NVL retorna b se a é NULL',
      'NVL2 é mais rápido',
      'Não há diferença',
    ],
    correctAnswer: 1,
    explanation: 'NVL2(a, b, c) retorna b se a NÃO é NULL, retorna c se a É NULL. É como um IF ternário para NULLs.',
    difficulty: 'medium',
    tags: ['conditional-functions', 'nvl'],
  },

  // CTEs
  {
    id: 'qc-sql-12',
    topicId: 'topic-1-2',
    domainId: 'domain-1',
    question: 'Qual palavra-chave é necessária para criar uma CTE recursiva?',
    options: ['LOOP', 'RECURSIVE', 'ITERATE', 'WITH'],
    correctAnswer: 1,
    explanation: 'Para CTEs recursivas, use WITH RECURSIVE. A CTE deve ter um anchor member e um recursive member unidos por UNION ALL.',
    difficulty: 'easy',
    tags: ['cte', 'recursive'],
  },
  {
    id: 'qc-sql-13',
    topicId: 'topic-1-2',
    domainId: 'domain-1',
    question: 'Em uma CTE recursiva, o que une o anchor member e o recursive member?',
    options: ['UNION', 'UNION ALL', 'JOIN', 'CONNECT BY'],
    correctAnswer: 1,
    explanation: 'UNION ALL é obrigatório entre o anchor member (caso base) e o recursive member (que referencia a CTE). UNION não é permitido.',
    difficulty: 'medium',
    tags: ['cte', 'recursive'],
  },

  // Joins
  {
    id: 'qc-sql-14',
    topicId: 'topic-1-3',
    domainId: 'domain-1',
    question: 'Qual tipo de JOIN permite uma subquery na cláusula FROM referenciar colunas de tabelas anteriores?',
    options: ['CROSS JOIN', 'NATURAL JOIN', 'LATERAL JOIN', 'SELF JOIN'],
    correctAnswer: 2,
    explanation: 'LATERAL JOIN permite que a subquery referencie colunas de tabelas à esquerda na mesma cláusula FROM, funcionando como subquery correlacionada.',
    difficulty: 'hard',
    tags: ['joins', 'lateral'],
  },
  {
    id: 'qc-sql-15',
    topicId: 'topic-1-3',
    domainId: 'domain-1',
    question: 'Qual operação de conjunto retorna linhas que existem em ambas as queries?',
    options: ['UNION', 'INTERSECT', 'EXCEPT', 'MINUS'],
    correctAnswer: 1,
    explanation: 'INTERSECT retorna apenas linhas que existem em ambas as queries. EXCEPT/MINUS retorna linhas na primeira que não estão na segunda.',
    difficulty: 'easy',
    tags: ['set-operations'],
  },
  {
    id: 'qc-sql-16',
    topicId: 'topic-1-3',
    domainId: 'domain-1',
    question: 'Qual é a diferença entre UNION e UNION ALL?',
    options: [
      'UNION ALL é mais lento',
      'UNION remove duplicatas, UNION ALL mantém todas',
      'UNION ALL requer mesmo número de colunas, UNION não',
      'Não há diferença',
    ],
    correctAnswer: 1,
    explanation: 'UNION remove duplicatas (mais lento). UNION ALL mantém todas as linhas incluindo duplicatas (mais rápido). Use UNION ALL quando souber que não há duplicatas.',
    difficulty: 'easy',
    tags: ['set-operations', 'union'],
  },

  // Aggregations
  {
    id: 'qc-sql-17',
    topicId: 'topic-2-4',
    domainId: 'domain-2',
    question: 'Qual cláusula gera TODAS as combinações possíveis de agregação?',
    options: ['ROLLUP', 'CUBE', 'GROUPING SETS', 'GROUP BY ALL'],
    correctAnswer: 1,
    explanation: 'CUBE gera todas as 2^n combinações possíveis. ROLLUP gera apenas agregações hierárquicas (remove da direita). GROUPING SETS especifica combinações exatas.',
    difficulty: 'medium',
    tags: ['cube', 'grouping-sets'],
  },
  {
    id: 'qc-sql-18',
    topicId: 'topic-2-4',
    domainId: 'domain-2',
    question: 'Qual função identifica se uma coluna está em nível de subtotal em GROUPING SETS?',
    options: ['IS_SUBTOTAL()', 'GROUPING()', 'GROUP_LEVEL()', 'AGGREGATE_LEVEL()'],
    correctAnswer: 1,
    explanation: 'GROUPING(column) retorna 1 se a coluna está agregada (NULL por subtotal), 0 caso contrário. GROUPING_ID() retorna bitmask de múltiplas colunas.',
    difficulty: 'hard',
    tags: ['grouping-sets', 'grouping'],
  },

  // ============================================
  // DOMAIN 2: Semi-Structured Data
  // ============================================
  
  {
    id: 'qc-semi-1',
    topicId: 'topic-2-1',
    domainId: 'domain-2',
    question: 'Qual é o tamanho máximo de um valor VARIANT?',
    options: ['1 MB', '8 MB', '16 MB', '64 MB'],
    correctAnswer: 2,
    explanation: 'Um valor VARIANT pode ter no máximo 16 MB. Para dados maiores, divida em múltiplas linhas ou use tabelas separadas.',
    difficulty: 'medium',
    tags: ['variant', 'limits'],
  },
  {
    id: 'qc-semi-2',
    topicId: 'topic-2-1',
    domainId: 'domain-2',
    question: 'Qual função converte uma string JSON em VARIANT de forma segura (sem erro)?',
    options: ['PARSE_JSON()', 'TRY_PARSE_JSON()', 'TO_VARIANT()', 'JSON_PARSE()'],
    correctAnswer: 1,
    explanation: 'TRY_PARSE_JSON() retorna NULL se o JSON for inválido, enquanto PARSE_JSON() gera um erro. Use TRY_PARSE_JSON() para dados não confiáveis.',
    difficulty: 'easy',
    tags: ['json', 'try-functions'],
  },
  {
    id: 'qc-semi-3',
    topicId: 'topic-2-1',
    domainId: 'domain-2',
    question: 'Qual é a diferença entre IS NULL e IS_NULL_VALUE() para VARIANT?',
    options: [
      'Não há diferença',
      'IS NULL verifica SQL NULL, IS_NULL_VALUE() verifica JSON null',
      'IS_NULL_VALUE() é mais rápido',
      'IS NULL funciona apenas com strings',
    ],
    correctAnswer: 1,
    explanation: 'IS NULL verifica ausência de valor (SQL NULL). IS_NULL_VALUE() verifica se é um valor JSON null literal. PARSE_JSON(\'null\') retorna JSON null, que NÃO é SQL NULL!',
    difficulty: 'hard',
    tags: ['null', 'variant'],
  },
  {
    id: 'qc-semi-4',
    topicId: 'topic-2-1',
    domainId: 'domain-2',
    question: 'Qual função retorna o tipo de um valor VARIANT como string?',
    options: ['TYPE()', 'TYPEOF()', 'GET_TYPE()', 'DATATYPE()'],
    correctAnswer: 1,
    explanation: 'TYPEOF() retorna o tipo como string: \'NULL_VALUE\', \'BOOLEAN\', \'INTEGER\', \'DOUBLE\', \'VARCHAR\', \'ARRAY\', \'OBJECT\'.',
    difficulty: 'easy',
    tags: ['variant', 'typeof'],
  },
  {
    id: 'qc-semi-5',
    topicId: 'topic-2-2',
    domainId: 'domain-2',
    question: 'Qual parâmetro do FLATTEN preserva linhas mesmo quando o array está vazio ou NULL?',
    options: ['KEEP_NULLS = TRUE', 'OUTER = TRUE', 'PRESERVE = TRUE', 'INCLUDE_EMPTY = TRUE'],
    correctAnswer: 1,
    explanation: 'OUTER = TRUE no FLATTEN preserva linhas do lado esquerdo mesmo quando o array está vazio ou NULL, similar a LEFT OUTER JOIN.',
    difficulty: 'medium',
    tags: ['flatten', 'outer'],
  },
  {
    id: 'qc-semi-6',
    topicId: 'topic-2-2',
    domainId: 'domain-2',
    question: 'Qual coluna do FLATTEN contém o índice do elemento em um array?',
    options: ['SEQ', 'KEY', 'INDEX', 'POSITION'],
    correctAnswer: 2,
    explanation: 'INDEX contém o índice do array (0-based). KEY contém a chave para objetos. SEQ é um número sequencial único. VALUE contém o valor.',
    difficulty: 'medium',
    tags: ['flatten', 'columns'],
  },
  {
    id: 'qc-semi-7',
    topicId: 'topic-2-3',
    domainId: 'domain-2',
    question: 'Qual função agrega valores de múltiplas linhas em um único array?',
    options: ['ARRAY_CONSTRUCT()', 'ARRAY_AGG()', 'COLLECT()', 'ARRAY_BUILD()'],
    correctAnswer: 1,
    explanation: 'ARRAY_AGG() agrega valores de múltiplas linhas em um array. ARRAY_CONSTRUCT() cria array de valores literais. Use ARRAY_AGG() WITHIN GROUP (ORDER BY...) para ordenar.',
    difficulty: 'easy',
    tags: ['array-agg', 'aggregation'],
  },
  {
    id: 'qc-semi-8',
    topicId: 'topic-2-3',
    domainId: 'domain-2',
    question: 'Qual função remove valores NULL de um array?',
    options: ['ARRAY_FILTER()', 'ARRAY_COMPACT()', 'ARRAY_CLEAN()', 'STRIP_NULL()'],
    correctAnswer: 1,
    explanation: 'ARRAY_COMPACT(array) remove todos os valores NULL do array. ARRAY_DISTINCT() remove duplicatas.',
    difficulty: 'easy',
    tags: ['array-functions'],
  },

  // ============================================
  // DOMAIN 3: Data Loading
  // ============================================
  
  {
    id: 'qc-load-1',
    topicId: 'topic-3-1',
    domainId: 'domain-3',
    question: 'Qual símbolo representa o User Stage?',
    options: ['@%', '@~', '@@', '@#'],
    correctAnswer: 1,
    explanation: '@~ representa o User Stage (criado automaticamente por usuário). @%tablename representa Table Stage. @ representa Named Stages.',
    difficulty: 'easy',
    tags: ['stages'],
  },
  {
    id: 'qc-load-2',
    topicId: 'topic-3-1',
    domainId: 'domain-3',
    question: 'Qual tipo de stage NÃO pode ser alterado ou dropado?',
    options: ['Named Stage', 'External Stage', 'User Stage', 'Table Stage'],
    correctAnswer: 2,
    explanation: 'User Stage (@~) e Table Stage (@%table) são criados automaticamente e não podem ser alterados ou dropados. Apenas Named Stages podem ser gerenciados.',
    difficulty: 'medium',
    tags: ['stages'],
  },
  {
    id: 'qc-load-3',
    topicId: 'topic-3-1',
    domainId: 'domain-3',
    question: 'Para conectar a um bucket S3 de forma segura e sem credenciais no código, o que você deve usar?',
    options: ['AWS_KEY_ID e AWS_SECRET_KEY', 'STORAGE_INTEGRATION', 'IAM_ROLE', 'S3_CREDENTIALS'],
    correctAnswer: 1,
    explanation: 'STORAGE_INTEGRATION usa IAM roles para acesso seguro sem expor credenciais. É a forma recomendada de conectar a cloud storage.',
    difficulty: 'medium',
    tags: ['stages', 'storage-integration'],
  },
  {
    id: 'qc-load-4',
    topicId: 'topic-3-2',
    domainId: 'domain-3',
    question: 'Qual opção do COPY INTO permite validar dados sem realmente carregá-los?',
    options: ['DRY_RUN = TRUE', 'VALIDATION_MODE', 'TEST_MODE = TRUE', 'VERIFY_ONLY = TRUE'],
    correctAnswer: 1,
    explanation: 'VALIDATION_MODE = RETURN_ALL_ERRORS ou RETURN_n_ROWS valida os dados e retorna erros/linhas sem carregar. Útil para testar antes de carregar.',
    difficulty: 'easy',
    tags: ['copy-into', 'validation'],
  },
  {
    id: 'qc-load-5',
    topicId: 'topic-3-2',
    domainId: 'domain-3',
    question: 'Qual opção força o recarregamento de arquivos já processados?',
    options: ['RELOAD = TRUE', 'FORCE = TRUE', 'REPROCESS = TRUE', 'IGNORE_HISTORY = TRUE'],
    correctAnswer: 1,
    explanation: 'FORCE = TRUE ignora o histórico de cargas e reprocessa arquivos mesmo se já foram carregados. Por padrão, Snowflake rastreia arquivos carregados.',
    difficulty: 'easy',
    tags: ['copy-into', 'force'],
  },
  {
    id: 'qc-load-6',
    topicId: 'topic-3-2',
    domainId: 'domain-3',
    question: 'Qual opção de file format remove o array externo de um arquivo JSON?',
    options: ['FLATTEN_ARRAY = TRUE', 'STRIP_OUTER_ARRAY = TRUE', 'UNWRAP_ARRAY = TRUE', 'EXTRACT_ARRAY = TRUE'],
    correctAnswer: 1,
    explanation: 'STRIP_OUTER_ARRAY = TRUE remove os colchetes externos [ ] de um arquivo JSON, tratando cada elemento como uma linha separada.',
    difficulty: 'easy',
    tags: ['file-format', 'json'],
  },
  {
    id: 'qc-load-7',
    topicId: 'topic-3-3',
    domainId: 'domain-3',
    question: 'Qual função retorna o status atual de um Snowpipe?',
    options: ['PIPE_STATUS()', 'SYSTEM$PIPE_STATUS()', 'GET_PIPE_INFO()', 'SHOW PIPE STATUS'],
    correctAnswer: 1,
    explanation: 'SYSTEM$PIPE_STATUS(\'pipe_name\') retorna JSON com: executionState, pendingFileCount, lastIngestedTimestamp, etc.',
    difficulty: 'easy',
    tags: ['snowpipe', 'monitoring'],
  },
  {
    id: 'qc-load-8',
    topicId: 'topic-3-3',
    domainId: 'domain-3',
    question: 'Qual é a principal diferença de custo entre Snowpipe e COPY INTO?',
    options: [
      'Snowpipe é sempre mais barato',
      'COPY INTO usa warehouse (créditos por tempo), Snowpipe é serverless (créditos por arquivo)',
      'COPY INTO é gratuito',
      'Não há diferença de custo',
    ],
    correctAnswer: 1,
    explanation: 'COPY INTO usa um warehouse dedicado (pago por tempo de execução). Snowpipe usa compute serverless (pago por arquivo/dados processados). Para muitos arquivos pequenos, COPY pode ser mais econômico.',
    difficulty: 'medium',
    tags: ['snowpipe', 'copy-into', 'cost'],
  },

  // ============================================
  // DOMAIN 4: Snowflake Objects
  // ============================================
  
  {
    id: 'qc-obj-1',
    topicId: 'topic-4-1',
    domainId: 'domain-4',
    question: 'Qual característica é exclusiva de Secure Views?',
    options: [
      'Resultados são cacheados',
      'Definição SQL é oculta de usuários',
      'Podem usar JOINs',
      'São mais rápidas',
    ],
    correctAnswer: 1,
    explanation: 'Secure Views ocultam sua definição SQL. GET_DDL() e SHOW VIEWS não mostram a query. Porém, algumas otimizações do query optimizer são desabilitadas.',
    difficulty: 'easy',
    tags: ['secure-view'],
  },
  {
    id: 'qc-obj-2',
    topicId: 'topic-4-1',
    domainId: 'domain-4',
    question: 'Qual é uma limitação de Materialized Views?',
    options: [
      'Não podem usar agregações',
      'Não podem usar JOINs',
      'Não são atualizadas automaticamente',
      'Não podem filtrar dados',
    ],
    correctAnswer: 1,
    explanation: 'Materialized Views NÃO suportam: JOINs, subqueries, UDFs, funções não-determinísticas, HAVING, ORDER BY, LIMIT. Apenas agregações simples sobre uma tabela.',
    difficulty: 'hard',
    tags: ['materialized-view', 'limitations'],
  },
  {
    id: 'qc-obj-3',
    topicId: 'topic-4-2',
    domainId: 'domain-4',
    question: 'Qual a diferença entre UDF e Stored Procedure em termos de side effects?',
    options: [
      'Ambos permitem side effects',
      'Nenhum permite side effects',
      'UDF não permite side effects, Stored Procedure permite',
      'UDF permite, Stored Procedure não permite',
    ],
    correctAnswer: 2,
    explanation: 'UDFs são funções puras (apenas leitura, sem side effects). Stored Procedures podem executar DDL/DML, ter transações e modificar dados.',
    difficulty: 'medium',
    tags: ['udf', 'stored-procedure'],
  },
  {
    id: 'qc-obj-4',
    topicId: 'topic-4-2',
    domainId: 'domain-4',
    question: 'Qual tipo de função retorna uma tabela (múltiplas linhas)?',
    options: ['Scalar UDF', 'UDTF', 'Aggregate UDF', 'Window UDF'],
    correctAnswer: 1,
    explanation: 'UDTF (User-Defined Table Function) retorna uma tabela. É usada com TABLE(function_name()) e pode retornar múltiplas linhas e colunas.',
    difficulty: 'easy',
    tags: ['udtf'],
  },
  {
    id: 'qc-obj-5',
    topicId: 'topic-4-3',
    domainId: 'domain-4',
    question: 'Qual função verifica se um Stream tem dados pendentes antes de executar uma Task?',
    options: ['STREAM_HAS_DATA()', 'SYSTEM$STREAM_HAS_DATA()', 'CHECK_STREAM()', 'STREAM_PENDING()'],
    correctAnswer: 1,
    explanation: 'SYSTEM$STREAM_HAS_DATA(\'stream_name\') retorna TRUE se há mudanças não consumidas. Use na cláusula WHEN da Task para evitar execuções desnecessárias.',
    difficulty: 'easy',
    tags: ['streams', 'tasks'],
  },
  {
    id: 'qc-obj-6',
    topicId: 'topic-4-3',
    domainId: 'domain-4',
    question: 'Qual coluna de metadados do Stream indica se uma mudança é parte de um UPDATE?',
    options: ['METADATA$ACTION', 'METADATA$ISUPDATE', 'METADATA$TYPE', 'METADATA$OPERATION'],
    correctAnswer: 1,
    explanation: 'METADATA$ISUPDATE = TRUE indica que a linha faz parte de um UPDATE (que aparece como DELETE + INSERT). METADATA$ACTION mostra \'INSERT\' ou \'DELETE\'.',
    difficulty: 'medium',
    tags: ['streams', 'metadata'],
  },
  {
    id: 'qc-obj-7',
    topicId: 'topic-4-3',
    domainId: 'domain-4',
    question: 'Como criar uma Task que executa após outra Task terminar?',
    options: [
      'DEPENDS ON parent_task',
      'AFTER parent_task',
      'FOLLOWS parent_task',
      'TRIGGERED BY parent_task',
    ],
    correctAnswer: 1,
    explanation: 'Use AFTER parent_task para criar Tasks dependentes. Isso cria uma Task Tree (DAG). Ative as Tasks filhas primeiro, depois a Task raiz.',
    difficulty: 'medium',
    tags: ['tasks', 'dag'],
  },
  {
    id: 'qc-obj-8',
    topicId: 'topic-4-4',
    domainId: 'domain-4',
    question: 'Qual é o período máximo de retenção de Time Travel na edição Enterprise?',
    options: ['7 dias', '30 dias', '90 dias', '365 dias'],
    correctAnswer: 2,
    explanation: 'Enterprise (e superiores): até 90 dias. Standard: apenas 0-1 dia. Configure com DATA_RETENTION_TIME_IN_DAYS.',
    difficulty: 'easy',
    tags: ['time-travel'],
  },
  {
    id: 'qc-obj-9',
    topicId: 'topic-4-4',
    domainId: 'domain-4',
    question: 'O que acontece com dados após o período de Time Travel expirar?',
    options: [
      'São deletados permanentemente',
      'Vão para Fail-safe por 7 dias',
      'São arquivados automaticamente',
      'São comprimidos',
    ],
    correctAnswer: 1,
    explanation: 'Após Time Travel, dados vão para Fail-safe por 7 dias adicionais. Durante Fail-safe, apenas Snowflake pode recuperar (via suporte). Sem acesso SQL.',
    difficulty: 'medium',
    tags: ['time-travel', 'fail-safe'],
  },
  {
    id: 'qc-obj-10',
    topicId: 'topic-4-4',
    domainId: 'domain-4',
    question: 'Qual comando restaura uma tabela dropada?',
    options: ['RESTORE TABLE', 'UNDROP TABLE', 'RECOVER TABLE', 'UNDELETE TABLE'],
    correctAnswer: 1,
    explanation: 'UNDROP TABLE table_name restaura uma tabela dropada dentro do período de Time Travel. Também funciona para SCHEMA e DATABASE.',
    difficulty: 'easy',
    tags: ['time-travel', 'undrop'],
  },

  // ============================================
  // DOMAIN 5: Performance
  // ============================================
  
  {
    id: 'qc-perf-1',
    topicId: 'topic-6-1',
    domainId: 'domain-6',
    question: 'Quantos créditos por hora consome um warehouse X-Large?',
    options: ['8', '16', '32', '64'],
    correctAnswer: 1,
    explanation: 'XL = 16 créditos/hora. Cada tamanho dobra: XS=1, S=2, M=4, L=8, XL=16, 2XL=32, 3XL=64, 4XL=128...',
    difficulty: 'medium',
    tags: ['warehouse', 'credits'],
  },
  {
    id: 'qc-perf-2',
    topicId: 'topic-6-1',
    domainId: 'domain-6',
    question: 'Qual scaling policy prioriza economia de custos?',
    options: ['STANDARD', 'ECONOMY', 'CONSERVATIVE', 'COST_OPTIMIZED'],
    correctAnswer: 1,
    explanation: 'ECONOMY escala clusters de forma conservadora para economizar custos (mais tempo enfileirando antes de adicionar cluster). STANDARD prioriza performance.',
    difficulty: 'easy',
    tags: ['warehouse', 'scaling-policy'],
  },
  {
    id: 'qc-perf-3',
    topicId: 'topic-6-1',
    domainId: 'domain-6',
    question: 'Qual recurso permite escalonamento horizontal automático para alta concorrência?',
    options: ['Auto-suspend', 'Auto-resume', 'Multi-cluster warehouse', 'Query acceleration'],
    correctAnswer: 2,
    explanation: 'Multi-cluster warehouses adicionam/removem clusters automaticamente baseado em demanda. Configure MIN_CLUSTER_COUNT e MAX_CLUSTER_COUNT.',
    difficulty: 'easy',
    tags: ['multi-cluster', 'warehouse'],
  },
  {
    id: 'qc-perf-4',
    topicId: 'topic-6-2',
    domainId: 'domain-6',
    question: 'Qual é o tamanho típico de uma micro-partition?',
    options: ['1-10 MB', '50-500 MB comprimidos', '1-5 GB', '10+ GB'],
    correctAnswer: 1,
    explanation: 'Micro-partitions têm tipicamente 50-500 MB de dados comprimidos. São criadas automaticamente e são imutáveis (copy-on-write).',
    difficulty: 'medium',
    tags: ['micro-partitions'],
  },
  {
    id: 'qc-perf-5',
    topicId: 'topic-6-2',
    domainId: 'domain-6',
    question: 'Qual função retorna informações sobre a qualidade do clustering?',
    options: ['CLUSTER_INFO()', 'SYSTEM$CLUSTERING_INFORMATION()', 'GET_CLUSTERING()', 'CLUSTERING_STATUS()'],
    correctAnswer: 1,
    explanation: 'SYSTEM$CLUSTERING_INFORMATION(table, columns) retorna estatísticas como average_depth, partition_depth_histogram, etc.',
    difficulty: 'medium',
    tags: ['clustering'],
  },
  {
    id: 'qc-perf-6',
    topicId: 'topic-6-2',
    domainId: 'domain-6',
    question: 'Para qual tipo de query o Search Optimization Service é mais eficaz?',
    options: [
      'Range scans (WHERE date BETWEEN ...)',
      'Full table scans',
      'Point lookups (WHERE id = ...)',
      'Aggregations (GROUP BY)',
    ],
    correctAnswer: 2,
    explanation: 'Search Optimization acelera point lookups (equality e IN) em tabelas grandes. Clustering é melhor para range scans. São complementares.',
    difficulty: 'hard',
    tags: ['search-optimization'],
  },
  {
    id: 'qc-perf-7',
    topicId: 'topic-6-3',
    domainId: 'domain-6',
    question: 'Por quanto tempo o result cache é válido?',
    options: ['1 hora', '12 horas', '24 horas', '7 dias'],
    correctAnswer: 2,
    explanation: 'Result cache é válido por 24 horas OU até que os dados subjacentes sejam modificados. É compartilhado entre usuários para queries idênticas.',
    difficulty: 'easy',
    tags: ['result-cache'],
  },
  {
    id: 'qc-perf-8',
    topicId: 'topic-6-3',
    domainId: 'domain-6',
    question: 'O que indica "Bytes spilled to remote storage" no Query Profile?',
    options: [
      'Dados em cache remoto',
      'Query excedeu memória e usou storage remoto (lento)',
      'Resultados salvos para cache',
      'Dados lidos de tabela externa',
    ],
    correctAnswer: 1,
    explanation: 'Spilling to remote storage indica que a query precisou de mais memória que o disponível. É pior que local spill. Solução: warehouse maior ou otimizar query.',
    difficulty: 'medium',
    tags: ['query-profile', 'spilling'],
  },

  // ============================================
  // DOMAIN 6: Data Sharing
  // ============================================
  
  {
    id: 'qc-share-1',
    topicId: 'topic-5-3',
    domainId: 'domain-5',
    question: 'No Secure Data Sharing, quem paga pelo compute das queries?',
    options: [
      'O provider (quem compartilha)',
      'O consumer (quem consome)',
      'Ambos dividem',
      'É gratuito',
    ],
    correctAnswer: 1,
    explanation: 'O consumer paga pelo compute (warehouse) para queries nos dados compartilhados. O provider continua pagando pelo storage.',
    difficulty: 'medium',
    tags: ['data-sharing', 'cost'],
  },
  {
    id: 'qc-share-2',
    topicId: 'topic-5-3',
    domainId: 'domain-5',
    question: 'O que é um Reader Account?',
    options: [
      'Uma conta somente-leitura normal',
      'Uma conta gerenciada pelo provider para consumidores sem Snowflake',
      'Um tipo de role com permissões limitadas',
      'Uma conta para visualização de dashboards',
    ],
    correctAnswer: 1,
    explanation: 'Reader Accounts são contas gerenciadas criadas pelo provider para consumidores que não têm conta Snowflake própria. Provider paga compute + storage.',
    difficulty: 'hard',
    tags: ['data-sharing', 'reader-account'],
  },

  // ============================================
  // DOMAIN 7: Security
  // ============================================
  
  {
    id: 'qc-sec-1',
    topicId: 'topic-4-1',
    domainId: 'domain-4',
    question: 'Qual role tem TODOS os privilégios na conta?',
    options: ['SYSADMIN', 'SECURITYADMIN', 'ACCOUNTADMIN', 'SUPERUSER'],
    correctAnswer: 2,
    explanation: 'ACCOUNTADMIN combina todos os privilégios: SYSADMIN (objetos) + SECURITYADMIN (usuários/roles) + gerenciamento de conta. Use com cautela!',
    difficulty: 'easy',
    tags: ['roles', 'rbac'],
  },
  {
    id: 'qc-sec-2',
    topicId: 'topic-4-1',
    domainId: 'domain-4',
    question: 'Qual comando concede automaticamente privilégios para objetos criados no futuro?',
    options: ['GRANT ALL ON FUTURE', 'GRANT ON FUTURE TABLES IN SCHEMA', 'AUTO GRANT', 'GRANT WITH FUTURE'],
    correctAnswer: 1,
    explanation: 'GRANT privilege ON FUTURE TABLES IN SCHEMA schema TO ROLE role aplica o grant automaticamente a todas as tabelas criadas no futuro naquele schema.',
    difficulty: 'medium',
    tags: ['grants', 'future-grants'],
  },
  {
    id: 'qc-sec-3',
    topicId: 'topic-4-1',
    domainId: 'domain-4',
    question: 'O que é uma Masking Policy?',
    options: [
      'Política de backup automático',
      'Política para ocultar/mascarar valores de colunas baseado em condições',
      'Política de retenção de dados',
      'Política de compressão',
    ],
    correctAnswer: 1,
    explanation: 'Masking Policy permite ocultar ou transformar valores de colunas baseado em condições (role, user, etc). Por exemplo: mostrar SSN completo para ADMIN, mascarado para outros.',
    difficulty: 'medium',
    tags: ['masking-policy', 'security'],
  },
  {
    id: 'qc-sec-4',
    topicId: 'topic-4-1',
    domainId: 'domain-4',
    question: 'Qual é a diferença entre Masking Policy e Row Access Policy?',
    options: [
      'Não há diferença',
      'Masking Policy filtra colunas, Row Access Policy filtra linhas',
      'Masking Policy oculta valores de colunas, Row Access Policy filtra linhas',
      'Row Access Policy é mais rápida',
    ],
    correctAnswer: 2,
    explanation: 'Masking Policy: oculta/transforma valores de COLUNAS (column-level security). Row Access Policy: filtra LINHAS que o usuário pode ver (row-level security).',
    difficulty: 'hard',
    tags: ['masking-policy', 'row-access-policy'],
  },
  {
    id: 'qc-sec-5',
    topicId: 'topic-6-1',
    domainId: 'domain-6',
    question: 'Qual ação de Resource Monitor suspende queries em execução imediatamente?',
    options: ['SUSPEND', 'ABORT', 'SUSPEND_IMMEDIATE', 'KILL'],
    correctAnswer: 2,
    explanation: 'SUSPEND_IMMEDIATE para o warehouse imediatamente, podendo cancelar queries em execução. SUSPEND espera queries terminarem. NOTIFY apenas notifica.',
    difficulty: 'easy',
    tags: ['resource-monitor'],
  },

  // ============================================
  // DOMAIN 8: Snowsight
  // ============================================
  
  {
    id: 'qc-sight-1',
    topicId: 'topic-5-1',
    domainId: 'domain-5',
    question: 'Qual função retorna o nome do warehouse atualmente em uso?',
    options: ['WAREHOUSE()', 'CURRENT_WAREHOUSE()', 'GET_WAREHOUSE()', 'SESSION_WAREHOUSE()'],
    correctAnswer: 1,
    explanation: 'CURRENT_WAREHOUSE() retorna o nome do warehouse ativo. Outras context functions: CURRENT_DATABASE(), CURRENT_SCHEMA(), CURRENT_ROLE(), CURRENT_USER().',
    difficulty: 'easy',
    tags: ['context-functions'],
  },
  {
    id: 'qc-sight-2',
    topicId: 'topic-5-1',
    domainId: 'domain-5',
    question: 'Como definir uma variável de sessão no Snowsight worksheet?',
    options: [
      'DECLARE @var = value',
      'SET var = value',
      'LET var = value',
      'DEFINE var = value',
    ],
    correctAnswer: 1,
    explanation: 'SET var = value define uma variável de sessão. Use $var ou :var (em worksheets Snowsight) para referenciar. Ex: SELECT * FROM table WHERE col = $var',
    difficulty: 'easy',
    tags: ['variables', 'snowsight'],
  },
];
